"""
Задание 2. Массив размером 2m + 1, где m – натуральное число,
заполнен случайным образом. Найдите в массиве медиану.

Медианой называется элемент ряда, делящий его на
две равные по длине части:
в одной находятся элементы,
которые не меньше медианы,
в другой – не больше медианы.

Решите задачу тремя способами:

3) с помощью встроенной функции поиска медианы

сделайте замеры на массивах длиной 10, 100, 1000 элементов

В конце сделайте аналитику какой трех из способов оказался эффективнее
"""
from numpy import median as np_median
from statistics import median as st_median
# from task_2_1 import shell_sort
from random import randint
from timeit import timeit
from memory_profiler import memory_usage


# Сортировка методом Шелла.
def shell_sort(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2
    return arr


# Функция для замеров времени и памяти.
def memory_time_stats(func, arr):
    mem_before = memory_usage()[0]
    time_taken = timeit(lambda: func(arr.copy()), number=10000)
    mem_after = memory_usage()[0]

    print(f" Время работы: {time_taken} секунд")
    print(f" Использовано памяти: {mem_after - mem_before} MiB")
    return func(arr.copy())


# Функция для сравнения эффективности трех способов.
def compare(n):
    m = (n - 1) // 2
    arr = [randint(1, 100) for _ in range(n)]
    # Способ 1: встроенная функция поиска медианы statistics.median.
    print(f"Способ 1: statistics.median:")
    memory_time_stats(st_median, arr)

    # Способ 2: встроенная функция поиска медианы numpy.median.
    print(f"Способ 2: Использованием numpy.median:")
    memory_time_stats(np_median, arr)

    # Способ 3: функция поиска методом Шелла.
    print(f"Способ 3: Методом Шелла:")
    memory_time_stats(shell_sort, arr)


for i in (10, 100, 1000):
    print(f"Для массива длиной {i}:")
    compare(i)
    print("-" * 40)

"""
Промежуточнтые результаты:
Для массива длиной 10:
Способ 1: statistics.median:
 Время работы: 0.013751200007391162 секунд
 Использовано памяти: 0.0234375 MiB
Способ 2: Использованием numpy.median:
 Время работы: 0.3020795000047656 секунд
 Использовано памяти: 0.20703125 MiB
Способ 3: Методом Шелла:
 Время работы: 0.10190619999775663 секунд
 Использовано памяти: 0.00390625 MiB
----------------------------------------
Для массива длиной 100:
Способ 1: statistics.median:
 Время работы: 0.052994900004705414 секунд
 Использовано памяти: 0.0 MiB
Способ 2: Использованием numpy.median:
 Время работы: 0.3067799999989802 секунд
 Использовано памяти: 0.00390625 MiB
Способ 3: Методом Шелла:
 Время работы: 1.6583332999871345 секунд
 Использовано памяти: 0.0 MiB
----------------------------------------
Для массива длиной 1000:
Способ 1: statistics.median:
 Время работы: 0.9543845000007423 секунд
 Использовано памяти: 0.06640625 MiB
Способ 2: Использованием numpy.median:
 Время работы: 0.8879136999894399 секунд
 Использовано памяти: 0.01171875 MiB
Способ 3: Методом Шелла:
 Время работы: 26.456083500001114 секунд
 Использовано памяти: 0.11328125 MiB
----------------------------------------
Анализ:
    Для маленьких массивов (например, длиной 10) разница в скорости между сортировками незначительная, 
    так как все алгоритмы работают достаточно быстро.
    Для больших массивов (например, длиной 1000) стандартная сортировка Python (sorted()) значительно быстрее всех остальных методов. Это объясняется тем, 
    что она использует более эффективный алгоритм Timsort, 
    который работает за O(n lon(n) O (n) log n), 
    в то время как пузырьковая и сортировка вставками имеют сложность O(n2)O(n2).
    Использование сортировки Шелла и сортировки вставками также занимает больше времени, 
    чем стандартная сортировка Python, но их производительность заметно лучше, чем у пузырьковой сортировки.

Заключение:
    Для маленьких массивов (например, длиной до 100) разница в производительности не так велика, 
    но стандартная сортировка Python все равно остается на первом месте.
    Для больших массивов (например, 1000 и более элементов) стандартная сортировка Python (через sorted()) будет самой эффективной по времени.
    Пузырьковая сортировка и сортировка вставками показывают значительно худшие результаты, особенно для больших массивов.
"""
