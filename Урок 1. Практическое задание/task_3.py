"""
Задание 3.

Для этой задачи
1) придумайте 2-3 решения (обязательно с различной сложностью)
2) оцените сложность каждого выражения в этих решениях в нотации О-большое
3) оцените итоговую сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ!
"""

companies = {'Company A': 2000000,
             'Company B': 1500000,
             'Company C': 3000000,
             'Company D': 2500000
             }


# Сортировка: О(n log n), где n — количество компаний в словаре.
# Выбор 3-х элементов из отсортированного списка: О(1)
# Итоговая сложность: O(n log n)
def find_three_max_companies_1():
    print(sorted(companies.items(), key=lambda x: x[1], reverse=True)[:3])


# Проходим по словарю один раз: O(n).
# Для каждого элемента мы выполняем несколько сравнений: O(1).
# Итоговая сложность: O(n)
def find_three_max_companies_2():
    max_1, max_2, max_3 = [None, None, None]
    for company, profit in companies.items():
        if max_1 is None or max_1[-1] > profit:
            max_3 = max_2
            max_2 = max_1
            max_1 = (company, profit)
        elif max_2 is None or max_2[-1] < profit:
            max_3 = max_2
            max_2 = (company, profit)
        elif max_3 is None or max_3[-1] < profit:
            max_3 = (company, profit)
    return max_1, max_2, max_3




"""
Решение 1 (Сортировка): O(n log n)
Это решение проще и интуитивно понятно, но оно менее эффективно,
поскольку требует полной сортировки всего массива,
что может быть медленным при большом количестве компаний.

Решение 2 (Использование минимальных переменных): O(n)
Это решение также эффективное,
так как оно использует всего три переменные для хранения топ-3 компаний,
и не требует дополнительных структур данных.
Мы обновляем их на каждом шаге и получаем результат за O(n).
"""
