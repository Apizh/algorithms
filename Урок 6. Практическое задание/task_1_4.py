"""
Задание 1.

Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python

На каждый скрипт нужно два решения - исходное и оптимизированное.

Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler

Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler

Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.


ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.

Это файл для четвертого скрипта
Задание взял из Урок 2, task_4.
"""
"""
Задание 4.	Найти сумму n элементов следующего ряда чисел:
1 -0.5 0.25 -0.125 ...
Количество элементов (n) вводится с клавиатуры.

Пример:
Введите количество элементов: 3
Количество элементов - 3, их сумма - 0.75

Решите через рекурсию. В задании нельзя применять циклы.
Нужно обойтисть без создания массива!
"""
from timeit import timeit
from memory_profiler import memory_usage


# Определяем декоратор для измерения используемой памяти и подсчета затрачиваемого времени.
def count_memory_usage(func):
    """Counts memory usage and time usage of a function."""

    def wrapper(*args, **kwargs):
        start_mem = memory_usage()[0]
        time_test = timeit(lambda: func(*args, **kwargs), number=100000)
        result = func(*args, **kwargs)  # Вызываем функцию.

        # Замеряем память после выполнения функции.
        end_mem = memory_usage()[0]

        print(f"Время выполнения: {time_test:.6f} секунд")
        print(f"Использовано памяти: {end_mem - start_mem:.6f} MiB")
        return result

    return wrapper


# Рекурсивная функция для нахождения суммы чисел ряда.
@count_memory_usage
def sum_series_wrapper(num):
    def sum_series(n: int, current_term: float = 1.0, sign: int = 1) -> float:
        # Условие завершения рекурсии: если n <= 0, возвращаем 0.
        if n == 0:
            return 0

        # Добавляем текущий элемент в сумму и вызываем рекурсивно для оставшихся элементов.
        return sign * current_term + sum_series(n - 1, current_term / 2, -sign)

    return sum_series(num)


# Функция геометрической прогрессии.
@count_memory_usage
def sum_series_formula(n: int, r: float = -0.5, a1: int = 1) -> float:
    if r == 1:
        return a1 * n

    return a1 * (1 - r ** n) / (1 - r)


# Запуск рекурсивной функции для подсчёта суммы геометрической прогрессии.
sum_series_wrapper(100)
# Запуск функции для подсчёта суммы геометрической прогрессии.
sum_series_formula(100)

"""
Оптимизация заключалась в сокращении количества замеров времени и памяти,
что позволило снизить системную нагрузку и повысить точность профилирования.
Результаты показывают, что теперь мы получаем более четкое представление
о потреблении ресурсов при выполнении рекурсивной функции,
что также позволяет лучше понять её влияние на систему и возможности для дальнейшей оптимизации.
"""
