"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time


# Декоратор для замера времени выполнения функции
def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Запоминаем время начала
        result = func(*args, **kwargs)
        end_time = time.time()  # Запоминаем время окончания
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time:.6f} секунд")
        return result

    return wrapper


# a) Заполнение списка и словаря:
# Функция для заполнения списка
@measure_time
def fill_list(n: int) -> list:
    lst = []
    for i in range(n):
        lst.append(i)
    return lst


# Функция для заполнения словаря
@measure_time
def fill_dict(n: int) -> dict:
    d = {}
    for i in range(n):
        d[i] = i
    return d


"""
Оценка сложности:
1) Заполнение списка: при добавлении элемента в список сложность — О(1)
O(1), но если вам нужно добавлять элементы в конце списка с использованием цикла,
то сложность будет O(n), где n - количество элементов.
2) Заполнение словаря: добавление элемента в словарь происходит за O(1),
так как словарь использует хеш-таблицу для хранения ключей и значений.
"""


# b) Получение элемента из списка и словаря
# Функция для получения элемента из списка
@measure_time
def get_from_list(n: int) -> None:
    for i in range(n):
        _ = test_list[i]
    return None


# Функция для получения элемента из словаря
@measure_time
def get_from_dict(n: int) -> None:
    for i in range(n):
        _ = test_dict.get(i)
    return None


"""
Оценка сложности:
1) Получение элемента из списка: сложность O(1),
так как доступ по индексу в списке осуществляется за постоянное время.
2) Получение элемента из словаря: сложность также O(1),
так как словарь использует хеш-таблицу.
"""


# c) Удаление элемента из списка и словаря

# Функция для удаления элемента из списка
@measure_time
def remove_from_list(n: int) -> None:
    for index in range(n):
        test_list.pop()
    return None


# Функция для удаления элемента из словаря
@measure_time
def remove_from_dict(n: int) -> None:
    for i in range(n):
        del test_dict[i]
    return None


"""
Оценка сложности:
1) Удаление элемента из списка: сложность O(n),
так как после удаления элемента нужно сдвигать все элементы,
расположенные после удаленного.
2) Удаление элемента из словаря: сложность O(1), 
так как словарь использует хеш-таблицу для быстрого доступа и удаления по ключу.
"""

# Тестирование с замерами
if __name__ == "__main__":
    n = 100000  # Количество элементов для теста

    # Заполнение списка и словаря
    print("Тестирование заполнения списка:")
    test_list = fill_list(n)  # Заполнение списка для последующих тестов

    print("\nТестирование заполнения словаря:")
    test_dict = fill_dict(n)  # Заполнение словаря для последующих тестов

    # Получение элемента
    print("\nТестирование получения элемента из списка:")
    get_from_list(n)

    print("\nТестирование получения элемента из словаря:")
    get_from_dict(n)

    # Удаление элемента
    print("\nТестирование удаления элемента из списка:")
    remove_from_list(n)

    print("\nТестирование удаления элемента из словаря:")
    remove_from_dict(n)

"""
Оценка сложности:
1) Заполнение списка и словаря:
Операция заполнения списка и словаря выполняется за O(n),
где n — количество элементов. Мы выполняем операцию добавления для каждого элемента,
что линейно зависит от количества элементов.
Получение всех элементов:
2) Для списка и словаря получение всех элементов также выполняется за O(n),
так как нам нужно пройти по всем элементам.

3) Удаление всех элементов:
Для списка удаление всех элементов также выполняется за O(n),
так как мы удаляем каждый элемент по очереди.
Для словаря удаление всех элементов происходит за O(n), 
так как каждый элемент удаляется за константное время 
O(1), но мы выполняем операцию для всех n элементов.

Вывод:
Заполнение списка и словаря будет выполняться с линейной сложностью O(n).
Получение элементов и удаление всех элементов также будет иметь линейную сложность O(n),
но для словаря операции могут быть выполнены быстрее за счет его хеш-таблицы.
"""
